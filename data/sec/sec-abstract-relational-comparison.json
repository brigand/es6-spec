{"id":"sec-abstract-relational-comparison","html":"\n      <h1><span class=\"secnum\" id=\"sec-7.2.11\"><a href=\"/sec/sec-abstract-relational-comparison.html\" title=\"link to this section\">7.2.11</a></span> Abstract Relational Comparison</h1>\n\n      <p class=\"normalbefore\">The comparison <var>x</var> &lt; <var>y</var>, where <var>x</var> and <var>y</var> are values,\n      produces <b>true</b>, <b>false</b>, or <b>undefined</b> (which indicates that at least one operand is <b>NaN</b>). In\n      addition to <var>x</var> and <var>y</var> the algorithm takes a Boolean flag named <span class=\"nt\">LeftFirst</span> as a\n      parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed\n      upon <var>x</var> and <var>y</var>. It is necessary because ECMAScript specifies left to right evaluation of expressions.\n      The default value of <span class=\"nt\">LeftFirst</span> is <b>true</b> and indicates that the <var>x</var> parameter\n      corresponds to an expression that occurs to the left of the <var>y</var> parameter&#x2019;s corresponding expression. If\n      <span class=\"nt\">LeftFirst</span> is <b>false</b>, the reverse is the case and operations must be performed upon\n      <var>y</var> before <var>x</var>. Such a comparison is performed as follows:</p>\n\n      <ol class=\"proc\">\n        <li><a href=\"/sec/sec-returnifabrupt.html\">ReturnIfAbrupt</a>(<i>x</i>).</li>\n        <li><a href=\"/sec/sec-returnifabrupt.html\">ReturnIfAbrupt</a>(<i>y</i>).</li>\n        <li>If the <i>LeftFirst</i> flag is <b>true</b>, then\n          <ol class=\"block\">\n            <li>Let <i>px</i> be <a href=\"/sec/sec-toprimitive.html\">ToPrimitive</a>(<i>x</i>, hint Number).</li>\n            <li><a href=\"/sec/sec-returnifabrupt.html\">ReturnIfAbrupt</a>(<i>px</i>).</li>\n            <li>Let <i>py</i> be <a href=\"/sec/sec-toprimitive.html\">ToPrimitive</a>(<i>y</i>, hint Number).</li>\n            <li><a href=\"/sec/sec-returnifabrupt.html\">ReturnIfAbrupt</a>(<i>py</i>).</li>\n          </ol>\n        </li>\n        <li>Else the order of evaluation needs to be reversed to preserve left to right evaluation\n          <ol class=\"block\">\n            <li>Let <i>py</i> be <a href=\"/sec/sec-toprimitive.html\">ToPrimitive</a>(<i>y</i>, hint Number).</li>\n            <li><a href=\"/sec/sec-returnifabrupt.html\">ReturnIfAbrupt</a>(<i>py</i>).</li>\n            <li>Let <i>px</i> be <a href=\"/sec/sec-toprimitive.html\">ToPrimitive</a>(<i>x</i>, hint Number).</li>\n            <li><a href=\"/sec/sec-returnifabrupt.html\">ReturnIfAbrupt</a>(<i>px</i>).</li>\n          </ol>\n        </li>\n        <li>If both <i>px</i> and <i>py</i> are Strings, then\n          <ol class=\"block\">\n            <li>If <i>py</i> is a prefix of <i>px</i>, return <b>false</b>. (A String value <i>p</i> is a prefix of String value\n                <i>q</i> if <i>q</i> can be the result of concatenating <i>p</i> and some other String <i>r</i>. Note that any\n                String is a prefix of itself, because <i>r</i> may be the empty String.)</li>\n            <li>If <i>px</i> is a prefix of <i>py</i>, return <b>true</b>.</li>\n            <li>Let <i>k</i> be the smallest nonnegative integer such that the code unit at index <i>k</i> within <i>px</i> is\n                different from the code unit at index <i>k</i> within <i>py</i>. (There must be such a <i>k</i>, for neither\n                String is a prefix of the other.)</li>\n            <li>Let <i>m</i> be the integer that is the code unit value at index <i>k</i> within <i>px</i>.</li>\n            <li>Let <i>n</i> be the integer that is the code unit value at index <i>k</i> within <i>py</i>.</li>\n            <li>If <i>m</i> &lt; <i>n</i>, return <b>true</b>. Otherwise, return <b>false</b>.</li>\n          </ol>\n        </li>\n        <li>Else,\n          <ol class=\"block\">\n            <li>Let <i>nx</i> be <a href=\"/sec/sec-tonumber.html\">ToNumber</a>(<i>px</i>). Because <i>px</i> and <i>py</i> are primitive\n                values evaluation order is not important.</li>\n            <li><a href=\"/sec/sec-returnifabrupt.html\">ReturnIfAbrupt</a>(<i>nx</i>).</li>\n            <li>Let <i>ny</i> be <a href=\"/sec/sec-tonumber.html\">ToNumber</a>(<i>py</i>).</li>\n            <li><a href=\"/sec/sec-returnifabrupt.html\">ReturnIfAbrupt</a>(<i>ny</i>).</li>\n            <li>If <i>nx</i> is <b>NaN</b>, return <b>undefined</b>.</li>\n            <li>If <i>ny</i> is <b>NaN</b>, return <b>undefined</b>.</li>\n            <li>If <i>nx</i> and <i>ny</i> are the same Number value, return <b>false</b>.</li>\n            <li>If <i>nx</i> is <b>+0</b> and <i>ny</i> is <b>&#x2212;0</b>, return <b>false</b>.</li>\n            <li>If <i>nx</i> is <b>&#x2212;0</b> and <i>ny</i> is <b>+0</b>, return <b>false</b>.</li>\n            <li>If <i>nx</i> is <b>+&#x221E;</b>, return <b>false</b>.</li>\n            <li>If <i>ny</i> is <b>+&#x221E;</b>, return <b>true</b>.</li>\n            <li>If <i>ny</i> is <b>&#x2212;&#x221E;</b>, return <b>false</b>.</li>\n            <li>If <i>nx</i> is <b>&#x2212;&#x221E;</b>, return <b>true</b>.</li>\n            <li>If the mathematical value of <i>nx</i> is less than the mathematical value of <i>ny</i> &#x2014;note that these\n                mathematical values are both finite and not both zero&#x2014;return <b>true</b>. Otherwise, return\n                <b>false</b>.</li>\n          </ol>\n        </li>\n      </ol>\n\n      <div class=\"note\">\n        <p><span class=\"nh\">NOTE 1</span> Step 5 differs from step 11 in the algorithm for the addition operator <code>+</code>\n        (<a href=\"/sec/sec-addition-operator-plus.html\">12.7.3</a>) in using &#x201C;and&#x201D; instead of &#x201C;or&#x201D;.</p>\n      </div>\n\n      <div class=\"note\">\n        <p><span class=\"nh\">NOTE 2</span> The comparison of Strings uses a simple lexicographic ordering on sequences of code unit\n        values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and\n        collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the\n        Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form.\n        Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit\n        values differs from that on sequences of code point values.</p>\n      </div>\n    "}